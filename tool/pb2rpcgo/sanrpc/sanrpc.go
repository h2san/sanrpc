package sanrpc

import (
	"fmt"
	pb "github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/generator"
	"os"
	"strings"
	"text/template"
)

func init(){
	generator.RegisterPlugin(new(sanrpc))
}

type sanrpc struct {
	gen *generator.Generator
}

//Name returns the name of this plugin
func (t *sanrpc) Name() string {
	return "sanrpc"
}

//Init initializes the plugin.
func (t *sanrpc) Init(gen *generator.Generator) {
	t.gen = gen
}

// GenerateImports generates the import declaration for this file.
func (t *sanrpc) GenerateImports(file *generator.FileDescriptor) {
}

// Generate generates code for the services in the given file.
func (t *sanrpc) Generate(file *generator.FileDescriptor) {
	if len(file.FileDescriptorProto.Service) == 0 {
		return
	}

	for _, service := range file.FileDescriptorProto.Service {
		t.generatorServiceCode(service)
	}
}

func (t *sanrpc) generatorServiceCode(service *pb.ServiceDescriptorProto){
	spec := t.buildServiceSpec(service)

		servicedir := strings.ToLower(spec.ServiceName)
		if err :=os.MkdirAll(servicedir,os.ModePerm); err!= nil {
			fmt.Println(err)
		}

		svrfile := servicedir+"/"+servicedir+".go"

		file, err := os.Open(svrfile)
		if err != nil {
			file,err = os.Create(svrfile)
			if err!= nil{
				fmt.Println(err)
			}
			tmp:=template.Must(template.New("").Parse(tplService))
			err = tmp.Execute(file,spec)
			if err!= nil{
				fmt.Println(err)
			}
			file.Close()
		}


	for _, method := range spec.MethodList{
		methodFile := servicedir+"/"+strings.ToLower(method.MethodName)+".go"
		file, err := os.Open(methodFile)
		if err != nil {
			file,err = os.Create(methodFile)
			if err!= nil{
				fmt.Println(err)
			}
			tmp:=template.Must(template.New("").Parse(tplcgi))
			err = tmp.Execute(file,
				struct{
					Spec *ServiceSpec
					Method ServiceMethodSpec
				}{	spec,
					method,
				})
			if err!= nil{
				fmt.Println(err)
			}
			file.Close()
		}

	}

	mainfile := "server.go"
	file, err = os.Open(mainfile)
	if err != nil {
		file,err = os.Create(mainfile)
		if err!= nil{
			fmt.Println(err)
		}
		tmp:=template.Must(template.New("").Parse(tpltcpserver))
		err = tmp.Execute(file,spec)
		if err!= nil{
			fmt.Println(err)
		}
		file.Close()
	}
}

func (t *sanrpc) buildServiceSpec(service *pb.ServiceDescriptorProto) *ServiceSpec{
	spec := &ServiceSpec{
		ServiceName:generator.CamelCase(service.GetName()),
		PackageName:strings.ToLower(service.GetName()),
	}
	for _,m := range service.Method{
		spec.MethodList = append(spec.MethodList,ServiceMethodSpec{
			MethodName:generator.CamelCase(m.GetName()),
			InputTypeName:t.gen.TypeName(t.objectNamed(m.GetInputType())),
			OutputTypeName:t.gen.TypeName(t.objectNamed(m.GetOutputType())),
		})
	}
	return spec
}

type ServiceSpec struct{
	PackageName string
	ServiceName string
	MethodList []ServiceMethodSpec
}

type ServiceMethodSpec struct{
	MethodName string
	InputTypeName string
	OutputTypeName string
}

const tplService = `package {{.PackageName}}

type {{.ServiceName}} struct {

}
`

const tplcgi= `package {{.Spec.PackageName}}

import "context"

func (svr *{{.Spec.ServiceName}}) {{.Method.MethodName}} (ctx context.Context, req *{{.Method.InputTypeName}}, resp *{{.Method.OutputTypeName}}) error {
	return nil
}
`

// P forwards to g.gen.P.
func (t *sanrpc) P(args ...interface{}) { t.gen.P(args...) }

// generateService generates all the code for the named service
func (t *sanrpc) generateService(file *generator.FileDescriptor, service *pb.ServiceDescriptorProto, index int) {
	serviceName := service.GetName()
	t.P("// This following code was generated by sanrpc")
	t.P(fmt.Sprintf("// Gernerated from %s", file.GetName()))
	t.P(fmt.Sprintf(`type  %s struct {
		s model.Servant
	}
	`, serviceName))
	t.P()

	//generate SetServant
	t.P(fmt.Sprintf(`//SetServant is required by the servant interface.
	func (obj *%s) SetServant(s model.Servant){
		obj.s = s
	}
	`, serviceName))
	t.P()
	//generate AddServant
	t.P(fmt.Sprintf(`//AddServant is required by the servant interface
	func (obj *%s) AddServant(imp imp%s, objStr string){
		tars.AddServant(obj, imp, objStr)
	}`, serviceName, serviceName))

	//generate TarsSetTimeout
	t.P(fmt.Sprintf(`//TarsSetTimeout is required by the servant interface. t is the timeout in ms. 
	func (obj *%s) TarsSetTimeout(t int){
		obj.s.TarsSetTimeout(t)
	}
	`, serviceName))
	t.P()

	//generate the interface
	t.P(fmt.Sprintf("type imp%s interface{", serviceName))
	for _, method := range service.Method {
		t.P(fmt.Sprintf("%s (input %s) (output %s, err error)",
			method.GetName(), t.typeName(method.GetInputType()), t.typeName(method.GetOutputType())))
	}
	t.P("}")
	t.P()

	for _, method := range service.Method {
		t.generateClientCode(service, method)
	}
}

// Given a type name defined in a .proto, return its name as we will print it.
func (t *sanrpc) typeName(str string) string {
	return t.gen.TypeName(t.objectNamed(str))
}

// Given a type name defined in a .proto, return its object.
// Also record that we're using it, to guarantee the associated import.
func (t *sanrpc) objectNamed(name string) generator.Object {
	t.gen.RecordTypeUse(name)
	return t.gen.ObjectNamed(name)
}

func (t *sanrpc) generateClientCode(service *pb.ServiceDescriptorProto, method *pb.MethodDescriptorProto) {
	methodName := method.GetName()
	serviceName := service.GetName()
	inType := t.typeName(method.GetInputType())
	outType := t.typeName(method.GetOutputType())
	t.P(fmt.Sprintf(`// %s is client rpc method as defined
		func (obj *%s) %s(input %s)(output %s, err error){
			var _status map[string]string
			var _context map[string]string
			var inputMarshal []byte
			inputMarshal, err = proto.Marshal(&input)
			if err != nil {
				return output, err
			}
			resp := new(requestf.ResponsePacket)
			ctx := context.Background()
			err = obj.s.Tars_invoke(ctx, 0, "%s", inputMarshal, _status, _context, resp)
			if err != nil {
				return output, err
			}
			if err = proto.Unmarshal(tools.Int8ToByte(resp.SBuffer), &output); err != nil{
				return output, err
			}
			return output, nil
		}
	`, methodName, serviceName, methodName, inType, outType, method.GetName()))
}

const tpltcpserver = `package main

import (
	"flag"
	"github.com/h2san/sanrpc/protocol/sanrpc"
	"github.com/h2san/sanrpc/server"
	"{{.PackageName}}/{{.PackageName}}"
)

var (
	addr = flag.String("addr", "127.0.0.1:8972", "server address")
)

func main() {
	flag.Parse()

	s := server.NewRpcServer()
	s.RegisterService({{.PackageName}}.{{.ServiceName}}{})
	s.Serve("tcp", *addr)
}
`